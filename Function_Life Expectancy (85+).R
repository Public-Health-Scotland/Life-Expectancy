## Function_Life Expectancy (85+).R


## LE_Function(85+) will take populations and deaths data to create life tables and life expectancy at birth
## estimates with associated confidence intervals.  

## The function requires deahts and population data to grouped into 19 agebands (<1 year,1-4 years,5-9....to 85+) 

## Listed below are the tokens expected by the function

# run_name - set a run title/date to prevent output files overwriting those generated by previous iterations
# fp_deaths - file name for deaths data
# fp_pop - file name for pop data
# fp_output - path files to save outpit files to
# yearstart - first year of data you wish to use
# yearend - last year of data
# time_agg - Aggregation period used expressed in year, e.g. 1 (single year), 2, 3 etc


###############################################.
## Packages and filepaths ----
###############################################.

library(dplyr)    #data manipulations 
library(RcppRoll) #for rolling sums


if (server_desktop == "server") {
  temp_network <- "/PHI_conf/ScotPHO/Life Expectancy/Data/temporary/"
  output_network <- "/PHI_conf/ScotPHO/Life Expectancy/Data/Output Data/"
  
} else if (server_desktop == "desktop") {
  temp_network <- "//stats/ScotPHO/Life Expectancy/Data/temporary/"
  output_network <- "//stats/ScotPHO/Life Expectancy/Data/Output Data/"
}


###############################################.
## LE_function ----
###############################################.


LE_85_function <- function (run_name, fp_deaths, fp_pop, fp_output, yearstart, yearend, time_agg) {
  
  # open population rds file 
  data_deaths <- readRDS(paste0(temp_network,fp_deaths,".rds"))
  
  # open deaths rds file
  data_pop <- readRDS(paste0(temp_network,fp_pop,".rds"))
  
  # join population and deaths files prepared in main program 
  all_data<- left_join(data_pop, data_deaths, by = c("year", "sex_grp", "age_grp","geography")) %>%
    subset(year>=yearstart & year<=yearend)
  
  all_data$deaths[is.na(all_data$deaths)] <- 0 # Converting where deaths are NA's to 0s (mostly required for IZ level)
  
  #create label for time period calculated - uses time_agg token supplied.
  if(time_agg == 1){
    all_data <- all_data %>%
      mutate(time_period=paste0(as.character(year)," single year estimate"))
  }else if(time_agg != 1){
    all_data <- all_data %>%
      mutate(time_period = paste0(as.character(year-(time_agg-1))," to ",as.character(year)," (",time_agg," year aggregate)"))
  }
  
  #aggreate population & deaths according to time_aggregation token supplied
  all_data <- all_data %>%
    arrange(age_grp,sex_grp,year) %>%
    group_by(age_grp,sex_grp, geography) %>% 
    mutate(totpop = roll_sum(x = pop, time_agg, align = "right", fill = NA),
           totdeaths = roll_sum(x = deaths, time_agg, align = "right", fill = NA)) %>%
    subset(!is.na(totpop)) %>% #excluding NA rows 
    select (-pop, -deaths, -year) %>% #drop unaggregated pop and deaths column
    arrange(geography, time_period,sex_grp,age_grp) %>%
    ungroup ()
  
  #save out RDS for checking purposes
  saveRDS(all_data, file=paste0(temp_network,run_name,'-le_raw.rds'))
  
#Life table (replicates exactly previous methodolgy found in excel workbook provided by ONS)
  lifetable_data <- all_data %>%
    group_by(sex_grp, time_period, geography) %>%
    mutate(mx = totdeaths / totpop,              # death rate
           n = c(1,4,rep(5,17)),                 # age intervals (<1=1, 1-4 = 4, 5-85 = 5 years)
           ax = c(0.1, rep(0.5,18)) ,            # ax = Fraction of the age interval lived by those who die in the interval - chiang methodolgy sets ax to 0.1 for first age band and 0.5 for all others
           qx = case_when(age_grp == 19 ~ 1,     # qx = Conditional probability individual entering age band will die
                          TRUE ~ n*mx/(1+n*(1-ax)*mx)),
           px= 1-qx,                             # px = Conditional probability individual entering age band will survive
           radix = 100000 ,                      # set radix (total imaginary cohort population)
           pre_Ix = cumprod(1-qx)*radix ,        # first step in calculating life table pop - second step (to calculate Ix) uses a lag function which only seems to work when lag value already defined.
           Ix= case_when(age_grp == 1 ~ radix,   # Ix =  Life table population (usually 100,000 at birth)
                         TRUE ~ lag(pre_Ix)),
           dx = Ix*qx,                           # dx =  Number of life table deaths
           Lx = case_when(age_grp == 19 ~ Ix/mx,           # Lx = Total number of years lived during the time period. Last age group treated differently as this is wider/open ended age band
                          TRUE ~  n*(lead(Ix,1)+(ax*dx))),
           Tx = case_when(age_grp == 19 ~Lx, TRUE ~ rev(cumsum(rev(Lx)))),
           LEx =Tx/Ix,                          # Life expectancy
           var_qx=(n^2*mx*(1-ax*n*mx))/(totpop*(1+(1-ax)*n*mx)^3),  #variance of qx (prob of death) 1984 method
           se1=case_when(age_grp==19 ~0, TRUE ~ (Ix^2)*(((1-ax)*n+lead(LEx,1))^2)*var_qx), # deriving standard error - requires 2 steps (se1 & se2)
           se2=rev(cumsum(rev(se1))),
           var_ex=se2/(Ix^2),     # variance of life expectancy
           se=sqrt(var_ex),       # standard error of life expectancy
           lci=LEx-(1.96*se),     # 95% lower confidence interval
           uci=LEx+(1.96*se)) %>%     # 95% upper confidence interval
    ungroup ()
  
  
  le0_data<-  lifetable_data %>% 
    group_by(geography,time_period, sex_grp) %>%
    mutate(pop=sum(totpop), deaths=sum(totdeaths)) %>%
    ungroup() %>%
    subset(age_grp==1) %>% #generate table for life expectancy at birth with confidence intervals.
    select(geography,time_period,sex_grp,pop,deaths, LEx, lci, uci ) %>%
    arrange(geography, sex_grp,time_period)
  
  saveRDS(lifetable_data, file=paste0(output_network,fp_output,"/",run_name,'_full life table.rds'))  
  saveRDS(le0_data, file=paste0(output_network,fp_output,"/",run_name, '_life expectancy at birth.rds'))
  
}

 




